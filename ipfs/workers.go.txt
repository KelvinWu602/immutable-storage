// package ipfs

// import (
// 	"log"
// 	"time"
// )

// func (ipfs IPFS) updateIndexDirectoryWorker(timeout time.Duration) {
// 	//TODO

// 	// for each round
// 	for {
// 		// obtain ip list
// 		// peers := []string{"1.1.1.1", "2.2.2.2", "3.3.3.3"}
// 		// port := "3101"
// 		// for _, peer := range peers {
// 		// 	// addr := peer + port
// 		// 	// //	make a grpc call to peer for the  grpc endpoint
// 		// 	// grpcclient, ctx, cancel, err := createClusterClient(addr, timeout)
// 		// 	// if err != nil {
// 		// 	// 	log.Println("failed to connect to", addr)
// 		// 	// }
// 		// 	// res, err := grpcclient.GetNodetxtIPNS(*ctx, &protos.GetNodetxtIPNSRequest{})
// 		// 	// if err != nil {
// 		// 	// 	log.Println("failed to GetNodetxtIPNS from", addr)
// 		// 	// }
// 		// 	// log.Println("Successfully GetNodetxtIPNS from", addr)
// 		// 	// (*cancel)()

// 		// 	// ok, err := validateMappingsIPNS(ipfs.daemon, res.NodetxtIPNS, 1)
// 		// 	// if err != nil || !ok {
// 		// 	// 	log.Println("received an invalid IPNS")
// 		// 	// 	continue
// 		// 	// }
// 		// 	// seen := make(map[string]bool) // ipns -> seen
// 		// 	// existing, err := parseNodesIPNS(ipfs.daemon, ipfs.nodesIPNS)
// 		// 	// if err != nil {
// 		// 	// 	log.Println(err)
// 		// 	// 	continue
// 		// 	// }
// 		// 	// for _, entry := range existing {
// 		// 	// 	seen[entry] = true
// 		// 	// }
// 		// 	// external, err := parseNodesIPNS(ipfs.daemon, res.NodetxtIPNS)
// 		// 	// if err != nil {
// 		// 	// 	log.Println(err)
// 		// 	// 	continue
// 		// 	// }
// 		// 	// for _, entry := range external {
// 		// 	// 	// append entry to nodes.txt
// 		// 	// 	if err := ipfs.daemon.appendStringToFile("/nodes.txt", entry+";", nodestxtMaxSize); err != nil {
// 		// 	// 		log.Println("error when append new IPNS to nodes.txt, source =", res.NodetxtIPNS)
// 		// 	// 		log.Println(err)
// 		// 	// 		continue
// 		// 	// 	}
// 		// 	// }
// 		// }
// 	}
// }

// func (ipfs IPFS) updateMappingWorker() {
// 	//TODO: allow termination of main goroutine to terminate the worker as well
// 	//TODO: consider retrying mechanism when discover a page or record fails due to network errors (using a DLQ)

// 	// for each round
// 	for {
// 		// obtain the current list of ipns from local nodes.txt
// 		ipnsRecords, err := parseNodesIPNS(ipfs.daemon, ipfs.nodesIPNS)
// 		if err != nil {
// 			// print the error, wait for 1s, continue
// 			log.Println(err)
// 			time.Sleep(1 * time.Second)
// 			continue
// 		}
// 		for _, ipns := range ipnsRecords {
// 			//check if we have created a profile for it
// 			progress, ok := ipfs.discoverProgress[ipns]
// 			if !ok {
// 				//first time seeing the ipns, initialize discover progress profile
// 				ipfs.discoverProgress[ipns] = discoverProgressProfile{
// 					nextReadPage:        0,
// 					nextReadEntryOffset: 0,
// 					lastCommitCID:       "",
// 				}
// 			}

// 			//check if the /mappings cid changed
// 			cid, err := ipfs.daemon.resolveIPNSPointer(ipns)
// 			if err != nil {
// 				log.Println(err)
// 				continue
// 			}
// 			if progress.lastCommitCID != cid {
// 				// get all mapping pages filenames and cids
// 				mappingPages, err := ipfs.daemon.getDAGLinks(cid)
// 				if err != nil {
// 					log.Println(err)
// 					continue
// 				}

// 				// while there is page haven't been read
// 				for progress.nextReadPage < uint(len(mappingPages)) {
// 					nextReadFileName := pageNumberToFileName(progress.nextReadPage)
// 					nextReadFileCid, ok := mappingPages[nextReadFileName]
// 					if !ok {
// 						// if a certain page is unfound, skip it
// 						log.Printf("Cannot find %s in IPNS %s\n", nextReadFileName, ipns)
// 						progress.nextReadPage++
// 						continue
// 					}
// 					entries, err := parseMappingsCID(ipfs.daemon, nextReadFileCid)
// 					if err != nil {
// 						// if a certain page content is invalid, skip it
// 						log.Println(err)
// 						progress.nextReadPage++
// 						continue
// 					}
// 					for row := progress.nextReadEntryOffset; row < uint(len(entries)); row++ {
// 						entry := entries[row]
// 						ok, err := validateMapping(ipfs.daemon, entry.key, entry.cid)
// 						if err != nil || !ok {
// 							log.Println("Found an invalid entry")
// 							continue
// 						}
// 						// add the entry into keyToCid
// 						ipfs.keyToCid[entry.key] = cidProfile{cid: entry.cid, source: ipns}
// 					}
// 					// update the nextReadEntryOffset
// 					progress.nextReadEntryOffset = uint(len(entries))
// 					if progress.nextReadEntryOffset >= 512 {
// 						progress.nextReadEntryOffset = 0
// 						progress.nextReadPage++
// 					}
// 				}
// 				// update the last commit CID
// 				progress.lastCommitCID = cid
// 			}
// 			ipfs.discoverProgress[ipns] = progress
// 		}
// 	}
// }
